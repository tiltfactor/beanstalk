/*================================================
=            Levenshtein Modification            =
================================================*/
/**
 * This function calculates the levenshtein distance and returns the closest
 * OCR entry for the user input.
 *
 * We do this so that we can always guess at what the user is trying to type.
 * Especially useful for words such as "Hosakia" when the OCR agrees on an
 * incorrect transcription.
 *
 * @param  {String} input       The Users input.
 * @param  {Array}  ocrOptions  A matrix of the ocr options.
 *
 * @return {Object}             An object with the id of the difference it
 * should match, and whether or not the user should be rewarded for their
 * input.
 */
var closestWord = function(input, differences) {
  // First return the closest row in the matrix.
  var closestOcr = _.min(differences, function(difference) {
    var ocr1 = difference.texts[0].toLowerCase();
    var ocr2 = difference.texts[1].toLowerCase();
    var l1 = new Levenshtein(input.toLowerCase(), ocr1);
    var l2 = new Levenshtein(input.toLowerCase(), ocr2);
    return Math.min(l1.distance, l2.distance);
  });
  /**
   * In our result object we have two properties, the first being the result
   * of the word compare algorithm, which will tell us if the user should get
   * rewarded for their input.
   *
   * The second tells us what the id of the difference is so that we can send
   * the input to the database.
   *
   * @type {Object}
   */
  var match;
  var tagWin;
  if (wordCompare(input, closestOcr.texts[0], closestOcr.texts[1])) {
    match = true;
  } else {
    //console.log('looking for tags', closestOcr.tags);
    // We figure out if the users input matches any of the previous tags.
    tagWin = _.map(closestOcr.tags, function(tag) {
      //console.log('Comparing:', input, 'with', tag.text);
      if (tag.text.toLowerCase() === input.toLowerCase()) {
        return true;
      } else {
        return false;
      }
    });
    tagWin = _.compact(tagWin);
    if (tagWin.length > 0) {
      match = true;
    } else {
      match = false;
    }
  }
  var result = {
    match: match,
    closestOcr: closestOcr
    //ocrMatch: closestOcr.texts//[closestOcr.ocr1, closestOcr.ocr2]
  };
  //console.log(result);
  return result;
}

function Pattern(type, text) {
  this.type = type;
  this.text = text || null;
}

function findClosestIndex(input, ocrOptions) //of the options array in the form of [ocrA1][ocrA2]
  //  [ocrB1][ocrB2]
  //  [ocrC1][ocrC2]
  //  etc...
  //figure out which one has the OCR which is closest to the input
  //calculated by taking the percentage match of LCS matches over input length
  {
    var closestIndex = -1;
    var closestValue = 0;

    for (var i = 0; i < ocrOptions.length; i++) {
      if (ocrOptions[i] !== null) {
        var currentVal = closestValue;
        closestValue = Math.max(Math.max(calculateLCS(input, ocrOptions[i][0]).length / input.length, calculateLCS(input, ocrOptions[i][1]).length / input.length), closestValue);
        //console.log("Closest value index " + i + " is " + Math.max(calculateLCS(input, ocrOptions[i][0]).length / input.length, calculateLCS(input, ocrOptions[i][1]).length / input.length));
        if (closestValue != currentVal) {
          closestIndex = i;
        }
      }
    }
    return closestIndex;
  }

//Uses the pattern generated by LCS to verify user input
function wordCompare(originalInput, originalOcr1, originalOcr2) {

  var input = '\x02' + originalInput + '\x03';
  var ocr1 = '\x02' + originalOcr1 + '\x03'; //We add a special character to the start and end of each string
  var ocr2 = '\x02' + originalOcr2 + '\x03'; //This prevents players from adding characters at the start or end of any string
  //in which the OCR agrees on the first or last character, because the LCS segment at the start will be [special character][first character]
  //adding a character between these two will break the LCS and cause the player's input to be wrong


  //Check for a significant change in length
  if ((input.length - Math.max(ocr1.length, ocr2.length) > 3) || (input.length - Math.min(ocr1.length, ocr2.length) < -3)) {
    return false;
  }

  var lowerInput = input.toLowerCase();
  var pattern = getPattern(ocr1, ocr2);

  //These two lines (and the two on patternElt) allow the player to type 'e' in place of 'c' and 's' for 'f'
  //This is a temporary measure to account for these common errors in the sample data
  //Comment out to remove this functionality
  lowerInput = lowerInput.replace(/c/g, 'e'); // the '/g' construction makes it replace ALL instances of 'c', not just the first
  lowerInput = lowerInput.replace(/f/g, 's');
  //var caps = checkCaps(input,pattern,ocr1,ocr2);

  //Check for each element of the pattern in the input
  var i = 0;
  var j = 0;
  while (j < pattern.length) {
    var patternElt = pattern[j];


    if (patternElt.type === "conflict") {
      j++;
      continue;
    }

    //hardcoded to allow c to e errors and f to s errors
    patternElt.text = patternElt.text.replace(/c/g, 'e');
    patternElt.text = patternElt.text.replace(/f/g, 's');

    var next = lowerInput.substring(i).indexOf(patternElt.text);
    //console.log("lowerInput is " + lowerInput + " and patternElt is " + patternElt.text);
    if (next === -1) {
      //console.log("above sequence could not be found");
      return false;
    }
    i = next + patternElt.text.length;
    j++;
  }

  /*if(!caps){
    return false;
  }*/
  return true; //because the caps check cares about the first characters of each word, we have to send the initial input
  //without the start and end characters
}

//Find the longest common substring, inserting null characters into the gaps
function calculateLCS(str1, str2) {

  //Recursive inner function
  function LCS(pos1, pos2) {
    //If this call has been made before, return the result
    if (memoTable[pos1][pos2] !== undefined) {
      return memoTable[pos1][pos2];
    }

    var result;
    //If we've iterated to the end of a string, there's nothing in common
    if (pos1 >= str1.length || pos2 >= str2.length) {
      result = '';
      //If the next character matches, add that character to the substring
    } else if (str1[pos1] === str2[pos2]) {
      result = str1[pos1] + LCS(pos1 + 1, pos2 + 1);
    } else {
      var lcs1 = LCS(pos1 + 1, pos2);
      var lcs2 = LCS(pos1, pos2 + 1);
      if (countChars(lcs1) > countChars(lcs2)) {
        result = lcs1;
      } else {
        result = lcs2;
      }
      if (result[0] !== '\x00') {
        result = '\x00' + result;
      }
    }

    //Uses memoization to reduce cost of recursive calls
    memoTable[pos1][pos2] = result;
    return result;
  }

  //Memoization table
  var memoTable = create2DArray(str1.length + 1, str2.length + 1);

  return LCS(0, 0);
}

//Counts nonnull characters
function countChars(string) {
  return string.split('').filter(function(character) {
    return (character !== '\x00');
  }).length;
}

//Create array which contains x arrays of y elements each
function create2DArray(x, y) {
  var arr = new Array(x);
  for (var i = 0; i < x; i++) {
    arr[i] = new Array(y);
  }
  return arr;
}

//Gets array of patterns (using Pattern class)
function getPattern(ocr1, ocr2) {
  var lcsString = calculateLCS(ocr1.toLowerCase(), ocr2.toLowerCase());
  var lcsArray = [];
  var arrayIndex = 0;
  for (var i = lcsString.length - 1; i >= 0; i--) {
    if (lcsString[i] === '\x00') {
      if (lcsArray[arrayIndex] && lcsArray[arrayIndex].type === "match") {
        lcsArray.unshift(new Pattern("conflict"));
      }
    } else {
      if (lcsArray[arrayIndex] && lcsArray[arrayIndex].type === "match") {
        lcsArray[0].text = lcsString[i] + lcsArray[0].text;
      } else {

        lcsArray.unshift(new Pattern("match", lcsString[i]));
      }
    }
  }

  return lcsArray;
}

function checkCaps(input, pattern, ocr1, ocr2) {

  //Split the patterns into sections
  var sections = [];
  for (var i = 0; i < pattern.length; i++) {
    var text = pattern[i].text;
    //Check for null (i.e, conflict)
    if (text) {
      sections.push(text[0]);
      if (text.length > 1) {
        sections.push(text.substring(1));
      }
    }
  }

  //console.log(sections);

  for (var j = 0; j < sections.length; j++) {
    //Get the original version of each pattern element in each ocr and the input
    var patternLength = sections[j].length;
    var ocrIndex1 = ocr1.toLowerCase().indexOf(sections[j]);
    var ocrIndex2 = ocr2.toLowerCase().indexOf(sections[j]);
    var inputIndex = input.toLowerCase().indexOf(sections[j]);
    var ocrSub1 = ocr1.substr(ocrIndex1, patternLength); //pattern element in ocr1
    var ocrSub2 = ocr2.substr(ocrIndex2, patternLength); //pattern element in ocr2
    var inputSub = input.substr(inputIndex, patternLength); //pattern element in input

    ocr1 = ocr1.substring(ocrIndex1 + patternLength);
    ocr2 = ocr2.substring(ocrIndex2 + patternLength);
    input = input.substring(inputIndex + patternLength);

    //If both ocrSub1 and ocrSub2 are all uppercase, inputSub should also be uppercase
    if (ocrSub1 === ocrSub1.toUpperCase() && ocrSub2 === ocrSub2.toUpperCase()) {
      if (inputSub != inputSub.toUpperCase()) {
        return false;
      }
      //Same as above but for lowercase
    } else if (ocrSub1 === ocrSub1.toLowerCase() && ocrSub2 === ocrSub2.toLowerCase()) {
      if (inputSub != inputSub.toLowerCase()) {
        return false;
      }
      //If ocrSub1 and ocrSub2 do not agree, inputSub should still be one case or the other
    } else {
      if (inputSub !== inputSub.toUpperCase() && inputSub !== inputSub.toLowerCase()) {
        return false;
      }
    }
  }

  return true;
}
